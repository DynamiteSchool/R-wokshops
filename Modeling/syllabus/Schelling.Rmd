---
title: "Schelling"
author: "CC&PC"
date: "Summer School"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Schelling Segregation Model

Here are some code lines to prepare the simulation of Schelling's Model of spatial segregation.
We start by the environment.

### Environment

The environment is a static square grid of `size` *  `size` cells, filled at a given percentage `pctOccupied` of householder agents.

A cell can be occupied by a single householder only. 

Each householder belongs to one of two groups, denoted by color (here : Red, Blue).

Basic Schelling model suggest that agents is randomly affected to one groupe or the other (50% of chance), yet we write the code as if it could change in the future.

From the R code point of view, the environment is a matrix, and the state of the system is constituted by the values inside the matrix.
At a given location (i,j), the value of the cell will be either 0 (empty cell), 1 (Red household), or 2 (Blue houshold).

Cells are intialized with 0 at the creation of the `matrixState` matrix.
Households are randomly allocated in the grid by sampling (without replacement) positions.

Household groups are then determined randomly :  the cell value is chosen between 1 and 2 (this time with replacement)  using `pctRed` and `pctBlue`  as probabilities weights.




```{r setupState}


matrixSchellingState <-  function(size, pctOccupied=.5, pctRed=0.5, pctBlue=1-pctRed ){

matrixState <- matrix(NA,size,size)
nbAgents <- floor(pctOccupied * size^2)
householdCells <- sample(size ^ 2, nbAgents)
matrixState[householdCells] <-  sample(c(1,2), nbAgents, replace = T, prob = c(pctRed,pctBlue))
return(matrixState)
}
matrixState <-  matrixSchellingState(40,0.5,0.5, 0.5)
```


Now that the sate has been defined, we will code the `display` function, to actually see something.


##Display

Display uses the **ggplot** library, a wierd yet widely used library, with so fancy graphic renderings it seems impossible not to use it.
For the record, we give the non-ggplot version first, using the `image` function. 

N.B. matrix plot is counter-clockwise rotated by an angle of pi/2 ; here we don't care as there is no orientation problems in this theoretic example. 
This is because, by convention, we "naturally" draw *rows* of a matrix along what would be the Y-axis of a plot. 
According to the documentation : 
>  `image` interpret matrix as a table of f(x[i], y[j]) values, so that the x axis corresponds to row number and the y axis to >column number, with column 1 at the bottom, i.e. a 90 degree counter-clockwise rotation of the conventional printed layout of a matrix.

(the same phenomenon occurs with ggplot2 )


```{r displaySimple,eval=FALSE,fig.height=6, fig.width=6}
par(fin=c(6,6)) #plot size setup
image(matrixState, axes = FALSE,col=c("red","blue"))
```


To obtain the ggplot version , the state data structure has to be tweaked a little bit.
ggplot2 needs a data structure where each line is  an individual i.e. a piece of data, formed as follows:
```
    | Var1 | Var2 |    Var3  |
row1| 20   | 12.4 | "Batman" |
row2|  8   | 3.5  | "Robin"  |
```

in our case, pieces of data are householders, located in the grid by their coordinates (`Xcoord,Ycoord`), belonging to a group (`value`); so we need something like: 

```
      | Xcoord | Ycoord | Group |
          ⋮       ⋮       ⋮ 
row_n |   24   |   75   |   2   |
          ⋮       ⋮       ⋮
row_p |   58   |    8   |   1   |
```


Starting from a matrix structure, this transformation is done by the `melt` function.


```{r meltGGplot}
library(reshape2)
meltedState <- melt(matrixState, varnames = c("X","Y")) 
head(meltedState,10)  #to see what it looks like and get the column names
```



```{r displayGGplot, fig.height=6, fig.width=6, warning =FALSE}
library(ggplot2)
# color definitions  
colorMapping <- c("1"="red", "2"="blue") 

myggplot <- ggplot(meltedState, aes(x=X, y=Y)) +
  geom_raster(aes(fill=factor(value)))+
 scale_fill_manual(values = colorMapping, na.value="lightgrey")+
  theme_void()
myggplot 


```

this does the job, 
yet we can improve rendering by drawing household in cells as points, in a scattermap-like way:


```{r displayGGplotfancy, fig.height=6, fig.width=6}
# color definitions  
library(RColorBrewer)
#fancyColors <- brewer.pal(3,"Accent")
# declaration of colors by name
fancyColors <- c("1"="bisque", "2"="aquamarine") 

myggplot2 <- ggplot(meltedState, aes(x=X, y=Y)) +
  geom_point(size=1, aes(colour=factor(value)))+ #size has to be adjusted regarding the size of the state
 scale_color_manual( values=fancyColors, name="Group" )+
  theme_void()+
  coord_fixed(ratio = 1) + 
  ggtitle("Schelling state")
   
myggplot2            

#save as a function for later use
displayState <- function(mystate, dotSize=1){
 myggplot2 <- ggplot(mystate, aes(x=X, y=Y)) +
  geom_point(size=dotSize, aes(colour=factor(value)))+ #size has to be adjusted regarding the size of the state
 scale_color_manual( values=fancyColors, name="Group" )+
  theme_void()+
  coord_fixed(ratio = 1) + 
  ggtitle("Schelling state")
  return(myggplot2) 
}
```



## Dynamics




Each household "aims"" at finding a location where the proportion of similar households in the neighborhood (surrounding cells) is above a certain `tolerance` threshold. 
If a household is 
   
 At each simulation step, each agent :
 
 1. looks around and establish the proportion of similar householder in its (Moore) nieghborhood
 2. if this proportion is below the threshold → looks for another place where the proportion is above , remains in place otherwise.
 
 
 To achieve this beahavior , we need a way to figure out :

* the neighborhood af a householder
* evaluate householder "happiness" i.e. if the neighborhood fits the tolerance criterion.
* locations of  the empty cells of the grid
* locations of the adequate cells for each group are (i.e. whose neighborhood proportion of same group is below the tolerance threshold)


### Getting the neighborhood

We will start with the Moore neighborhood (the 8 adjacents cells of a cell) ; this defintion could be extended in a later version.


Given a coordinate (i,j) in the state matrix, the neighborhood is given by the following code. 
The `meAndMyNeighbors(i,j)` select the neighboring portion of the (i,j) cell in the `matrixState` matrix.
The `getgetneighbors(i,j)` transforms this portion in a more convenient format (a list) and excludes the calling cell (i,j) 
Special cases of corner and border cells are considered having incomplete neighborhood.

```{r neighbors}
meAndMyNeighbors <- function (mstate,i,j) {
#we assume world is square for now
    size <-  nrow(mstate)  
    # corners 
  if (j==1 & i==1 ){
    return(mstate[c(i, i + 1), c(j, j + 1)])
  } 
  if (j==size & i ==size){
    return(mstate[c(i-1, i), c(j-1, j)])
  } 
  if(i==size & j==1) {
    return(mstate[c(i-1, i ), c(j, j + 1)])
  }
  if(i==1 & j==size){
    return(mstate[c(i, i + 1), c(j-1, j)])
  }
  
  #borders without corners
  if (i==1 &  j > 1 & j < size) {
    return(mstate[c(i, i + 1), c(j-1,j, j+1)])
  }
  if(i==size & j >1 & j < size ){
    return(mstate[c(i-1, i), c(j-1,j, j+1)])
  }
  if(j==1 & i >1 & i < size){
        return(mstate[c(i-1, i, i+1), c(j, j+1)])
  }
  if(j==size & i >1 & i < size){
    return(mstate[c(i-1, i, i+1), c(j-1, j)])
  }
  #regular cell case
  if (i > 1 & i < size & j > 1 & j < size){
    return(mstate[c(i-1,i,i+1),c(j-1,j,j+1)])
  }
}

getneighbors <- function(mstate, i,j){
    neighborhood <- meAndMyNeighbors(mstate, i, j)
        # flatten the 3xn matrix as a list
    neighborhood <- as.vector(neighborhood)
  return(neighborhood)
}



```



### Evaluating cells "happiness"

Now we need to evaluate if the householder of a cell (i,j) is satisfied by its neighborhood , i.e. if the proportion of similar householders around him is  above the `tolerance` threshold.


````{r happiness}
tolerance <- 0.3  


isHappy <- function(state, i , j, tolerance){
  cell <-  state[i,j]
  if (is.na(cell)){return(NA)}
  neigh <- getneighbors(state,i,j)
  numberOfSimilar <-sum(cell==neigh, na.rm = T)  
  happy <-  numberOfSimilar / (length(neigh) ) > tolerance
  return(happy)  
} 
```

To test the function, we have to apply it to each cell of the matrix.
We use the melted state, where coordinates are immediately available for each cell.

``` {r testhappiness}
library(dplyr)

testEnv <-  createSchellingState(10,pctOccupied = 0.8)

# we use melted state for immediatley accessible coordinates
meltTestEnv <-  melt(testEnv,varnames = c("X","Y"))
displayState(meltTestEnv, dotSize = 5)

#handy rowwise operator form dplyr
meltTestEnv <-  meltTestEnv %>% rowwise() %>% mutate(happy= isHappy(state = testEnv,X,Y,0.3))


# we update the display function code
displayStateUnhappy <- function(meltedState){
  pp <- displayState(meltedState, dotSize = 5) + 
    geom_text(data = subset(meltedState, !happy ), aes(X,Y,label = ":-|"), angle=-90) 
return(pp)
  }


# save as function for later
getUnhappy <-  function(meltedState, tolerance){
  meltedState <-  updateHappiness(meltedState , tolerance )
  return(subset(meltedState, !happy))
}

updateHappiness <- function(meltedState, tolerance){
  mat <-  attr(meltedState, "matrix")
  return(meltedState %>% rowwise() %>% mutate(happy= isHappy(mat,X,Y,tolerance)))
}

createMeltedSchellingState <- function(size, pctOccupied=.5, pctRed=0.5, pctBlue=1-pctRed, tolerance){
  matState <-  matrixSchellingState(size, pctOccupied, pctRed, pctBlue)
  meltedState <-  melt(matState,varnames = c("X","Y"))
  meltedState <-  meltedState %>% rowwise() %>% mutate(happy= isHappy(state = matState,X,Y, tolerance ))
  # we add an explicit ID of cells (row number), it will be useful
  meltedState$ID <- seq.int(nrow(meltedState))
  attr(meltedState, "matrix") <- matState
  return(meltedState)
}
``` 



### Getting empty cells

Unsatisfied householders look for empty cells to relocate.
In our model, empty cells have a `NA`value.
We will create and maintain a subset of our meltedState, keeping track of the empty cells.
We use a function that filter the values of the melted state.

```{r }
getEmptyCells <-  function(meltedState){
  return(meltedState %>%filter(is.na(value))  )
}
emptyCells <-  getEmptyCells(meltTestEnv)

#we add a symbol layer  to check emptyness visually
pp <-  displayStateUnhappy(meltTestEnv) +
  geom_text(data = subset(meltTestEnv, is.na(value) ), aes(X,Y,label = sprintf("\U2205")), angle=-90)  
pp


#we update the function 

displayStateUnhappy <- function(mystate) {
  pp <- displayState(mystate , dotSize = 5) +
  geom_text(data = subset(mystate,!happy),  aes(X, Y, label = ":-|"),   angle = -90) +
  
  geom_text(  data = subset(mystate, is.na(value)),   aes(X, Y, label = sprintf("\U2205")),   angle = -90)
  
  return(pp)
}
```


### Moving to more satisfying locations

The idea is now to move unhappy households to another, empty location . 
For each householder, an empty location/cell is randomly drawn, and the householder establish itself in it .

To do that, we sample among empty cells, update these empty cells values according to unhappy householders values, and put the previous unhappy householders cells to`NA` (i.e. empty)



```{r move}
stateEnv <- createMeltedSchellingState(10,pctOccupied = 0.8, tolerance=0.3)

unhappy <-  getUnhappy(stateEnv)
numberOfUnHappy <-  nrow(unhappy)
emptyCells <-  getEmptyCells(stateEnv)
numberOfEmpty <-  nrow(getEmptyCells(stateEnv))
cat(numberOfEmpty , "\n") # has to be 20% since pctOccupied is 0.8 of size squared


# if there is more empty room than unhappy, we can move everyone in a single loop 
if (numberOfEmpty > numberOfUnHappy){

    futureOccupiedCells <-  sample_n(emptyCells, numberOfUnHappy)
    
    #when household settle , values are updated
    futureOccupiedCells$value <-  unhappy$value
    
    #newly occupied cells values are no longer NA , but the values of unhappyhouseholders
    stateEnv[futureOccupiedCells$ID,"value"] <-  futureOccupiedCells$value
    #previously occupied cells are set to empty
    stateEnv[unhappy$ID, "value"] <- NA 
}

# if there is more unhappy than empty cells, we can only move a subset of unhappy householders to empty locations
#code looks similar, notice the replacement of unhappy by a subset : futureMovers
if (numberOfEmpty < numberOfUnHappy){
  
    futureMovers <-  sample_n(unhappy, numberOfEmpty)
     futureOccupiedCells <-  emptyCells
    #when household settle , values are updated
    futureOccupiedCells$value <-  futureMovers$value
                                           
                                           
    #newly occupied cells values are no longer NA , but the values of unhappyhouseholders
    stateEnv[futureOccupiedCells$ID,"value"] <-  futureOccupiedCells$value
    #previously occupied cells are set to empty
    stateEnv[futureMovers$ID, "value"] <- NA 
  }


```


## Simulation Loop

Now that we have implemented one step of the model Dynamic , we can automate its execution in a loop, create some buttons and animate it in a `shiny` app (a library for GUI and reactive programming stuff)

Before we do that, we add the last lines of code in a function, 

```{r loopsimu}
step <- function(meltedState, tolerance){
  unhappy <-  getUnhappy(meltedState, tolerance)
  numberOfUnHappy <-  nrow(unhappy)
    
  if (numberOfUnHappy >0){
  emptyCells <-  getEmptyCells(meltedState)
  numberOfEmpty <-  nrow(getEmptyCells(meltedState))
  mover <-  sample_n(unhappy,1)
  futureCell <-  sample_n(emptyCells, 1)
  meltedState[futureCell$ID,"value"] <- mover$value
  meltedState[mover$ID, "value"] <- NA 
  }
  meltedState <-  updateHappiness(meltedState, tolerance)
    
  return(meltedState)
}


simulate <-  function(steps, state, tolerance){
  for (i in 1:steps){
    state <-  step(state, tolerance)
    
  }
}
```



Basically a simulation loop is a loop that repeat a simulation step a certain number of times or until a certain condition is reached.


```{r, echo=FALSE}
library(shiny)
shinyApp(
  ui = fluidPage(
     actionButton("go", "Go"),
   plotOutput("plot")
  ),

  server = function(input, output) {
    tolerance <-  0.3
    state <-createMeltedSchellingState(20, 0.8, 0.5, 0.5,tolerance)  
    currentState   <- eventReactive(input$go, {
    state <-  step(state, tolerance)
  })

  output$plot <- renderPlot({
    currentplot <-  displayStateUnhappy(currentState())
    currentplot
  })  }
  ,
   options = list(height = 500)
 )
```




