---
title: "Schelling"
author: "CC&PC"
date: "Summer School"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Schelling Segragation Model

Here are some code lines to prepare the simulation of Schelling's Model of spatial segregation.
We start by the environment.

### Environment

The environment is a static square grid of `size` *  `size` cells, filled at a given percentage `pctOccupied` of householder agents.

A cell can be occupied by a single householder only. 

Each householder belongs to one of two groups, denoted by color (here : Red, Blue).

Basic Schelling model suggest that agents is randomly affected to one groupe or the other (50% of chance), yet we write the code as if it could change in the future.

From the R code point of view, the environment is a matrix, and the state of the system is constituted by the values inside the matrix.
At a given location (i,j), the value of the cell will be either 0 (empty cell), 1 (Red household), or 2 (Blue houshold).

Cells are intialized with 0 at the creation of the `state` matrix.
Households are randomly allocated in the grid by sampling (without replacement) positions.

Household groups are then determined randomly :  the cell value is chosen between 1 and 2 (this time with replacement)  using `pctRed` and `pctBlue`  as probabilities weights.




```{r setupState}
size <- 10
pctOccupied <- 0.5
pctRed <- 0.5
pctBlue <- (1-pctRed)

state <- matrix(NA,size,size)
nbAgents <- floor(pctOccupied * size^2)
householdCells <- sample(size ^ 2, nbAgents)
state[householdCells] <-  sample(c(1,2), nbAgents, replace = T, prob = c(pctRed,pctBlue))
```


Now that the sate has been defined, we will code the `display` function, to actually see something.


##Display

Display uses the **ggplot** library, a wierd and fucked-up piece of software, with so fancy graphic renderings it seems impossible not to use it.
For the record, we give the non-ggplot version first, using the `image` function. 

N.B. matrix plot is counter-clockwise rotated by an angle of pi/2 ; here we don't care as there is no orientation problems in this theoretic example. 
This is because, by convention, we "naturally" draw *rows* of a matrix along what would be the Y-axis of a plot. 
According to the documentation : 
> `image` interpret matrix as a table of f(x[i], y[j]) values, so that the x axis corresponds to row number and the y axis to >column number, with column 1 at the bottom, i.e. a 90 degree counter-clockwise rotation of the conventional printed layout of a matrix.

(the same phenomenon occurs with ggplot2 )


```{r displaySimple,fig.height=6, fig.width=6}
par(fin=c(6,6)) #plot size setup
image(state, axes = FALSE,col=c("red","blue"))
```


To obtain the ggplot version , the state data structure has to be tweaked a little bit.
ggplot2 needs a data structure where each line is  an individual i.e. a piece of data, formed as follows:
```
    | Var1 | Var2 |    Var3  |
row1| 20   | 12.4 | "Batman" |
row2|  8   | 3.5  | "Robin"  |
```

in our case, pieces of data are householders, located in the grid by their coordinates (`Xcoord,Ycoord`), belonging to a group (`value`); so we need something like: 

```
      | Xcoord | Ycoord | Group |
          ⋮       ⋮       ⋮ 
row_n |   24   |   75   |   2   |
          ⋮       ⋮       ⋮
row_p |   58   |    8   |   1   |
```


Starting from a matrix structure, this transformation is done by the `melt` function.


```{r meltGGplot}
library(reshape2)
meltedState <- melt(state) 
head(meltedState,10)  #to see what it looks like and get the column names
```



```{r displayGGplot, fig.height=6, fig.width=6}
library(ggplot2)
# color definitions  
colorMapping <- c("1"="red", "2"="blue") 

myggplot <- ggplot(meltedState, aes(x=Var1, y=Var2)) +
  geom_raster(aes(fill=factor(value)))+
 scale_fill_manual(values = colorMapping, na.value="lightgrey")+
  theme_void()
myggplot            

```

this does the job, 
yet we can improve rendering by drawing household in cells as points, in a scattermap-like way:


```{r displayGGplotfancy, fig.height=6, fig.width=6}
# color definitions  
library(RColorBrewer)
#fancyColors <- brewer.pal(3,"Accent")
# declaration of colors by name
fancyColors <- c("1"="bisque", "2"="aquamarine") 

myggplot2 <- ggplot(meltedState, aes(x=Var1, y=Var2)) +
  geom_point(size=1, aes(colour=factor(value)))+ #size has to be adjusted regarding the size of the state
 scale_color_manual( values=fancyColors, name="Group" )+
  theme_void()+
  coord_fixed(ratio = 1) + 
  ggtitle("Schelling state")
   
myggplot2            


```



## Dynamics

Each household "aims"" at finding a location where the proportion of similar households in the neighborhood (surrounding cells) is above a certain `tolerance` threshold.
   
 At each simulation step, each agent :
 
 1. looks around and establish the proportion of similar householder in its (Moore) nieghborhood
 2. if this proportion is below the threshold → looks for another place where the proportion is above , remains in place otherwise.
 
 
 To achieve this beahavior , we need a way to figure out :
 - the neighborhood af a householder
 - where are the empty cells of the grid
 - where are the adequate cells for each group are (i.e. whose neighborhood proportion of same group is below the tolerance threshold)


### Getting the neighborhood

We will start with the Moore neighborhood (the 8 adjacents cells of a cell) ; this defintion could be extended in a later version.


Given a coordinate (i,j) in the state matrix, the neighborhood is given by the following code. 
The `meAndMyNeighbors(i,j)` select the neighboring portion of the (i,j) cell in the `state` matrix.
The `getgetneighbors(i,j)` transforms this portion in a more convenient format (a list) and excludes the calling cell (i,j) 
Special cases of corner and border cells are considered having incomplete neighborhood.

```{r neighbors}
meAndMyNeighbors <- function (i,j) {
  # corners 
  if (j==1 & i==1 ){
    return(state[c(i, i + 1), c(j, j + 1)])
  } 
  if (j==size & i ==size){
    return(state[c(i-1, i), c(j-1, j)])
  } 
  if(i==size & j==1) {
    return(state[c(i-1, i ), c(j, j + 1)])
  }
  if(i==1 & j==size){
    return(state[c(i, i + 1), c(j-1, j)])
  }
  
  #borders without corners
  if (i==1 &  j > 1 & j < size) {
    return(state[c(i, i + 1), c(j-1,j, j+1)])
  }
  if(i==size & j >1 & j < size ){
    return(state[c(i-1, i), c(j-1,j, j+1)])
  }
  if(j==1 & i >1 & i < size){
    return(state[c(i-1, i, i+1), c(j, j+1)])
  }
  if(j==size & i >1 & i < size){
    return(state[c(i-1, i, i+1), c(j-1, j)])
  }
  #regular cell case
  if (i > 1 & i < size & j > 1 & j < size){
    return(state[c(i-1,i,i+1),c(j-1,j,j+1)])
  }
}

getneighbors <- function(i,j){
  neighborhood <- meAndMyNeighbors(i,j)
  # flatten the 3x3 matrix as a list
  neighborhood <- as.vector(neighborsAndMe)
  #remove middle term (i.e. myself, the caller cell i,j )
  neighborhood <- neighborhood[-5]
  return(neighborhood)
}



```



### Evaluating cells "happiness"

Now we need to evaluate if the householder of a cell (i,j) is satisfied by its neighborhood , i.e. if the proportion of similar householders around him is  above the `tolerance` threshold.


````{r happiness}
tolerance <-0.3  

isHappy? <- function(i,j){
  neigh <- getneighbors(i,j)
  cell <-  state[i,j]
  numberOfSimilar <-sum(cell==neigh, na.rm = T)  
  happy <-  numberOfSimilar / length(neigh) > tolerance
  return(happy)  
} 
```


### Getting empty cells

Unsatisfied householders look for empty cells to relocate.
In our model 






 