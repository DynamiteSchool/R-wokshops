---
title: "Schelling"
author: "CC&PC"
date: "Summer School"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Schelling Segragation Model

Here are some code lines to prepare the simulation of Schelling's Model of spatial segregation.
We start by the environment.

### Environment

The environment is a static square grid of `size` *  `size` cells, filled at a given percentage `pctOccupied` of householder agents.

A cell can be occupied by a single householder only. 

Each householder belongs to one of two groups, denoted by color (here : Red, Blue).

Basic Schelling model suggest that agents is randomly affected to one groupe or the other (50% of chance), yet we write the code as if it could change in the future.

From the R code point of view, the environment is a matrix, and the state of the system is constituted by the values inside the matrix.
At a given location (i,j), the value of the cell will be either 0 (empty cell), 1 (Red household), or 2 (Blue houshold).

Cells are intialized with 0 at the creation of the `state` matrix.
Households are randomly allocated in the grid by sampling (without replacement) positions.

Household groups are then determined randomly :  the cell value is chosen between 1 and 2 (this time with replacement)  using `pctRed` and `pctBlue`  as probabilities weights.




```{r setupState}
size <- 10
pctOccupied <- 0.5
pctRed <- 0.5
pctBlue <- (1-pctRed)

state <- matrix(NA,size,size)
nbAgents <- floor(pctOccupied * size^2)
householdCells <- sample(size ^ 2, nbAgents)
state[householdCells] <-  sample(c("1","2"), nbAgents, replace = T, prob = c(pctRed,pctBlue))
```


Now that the sate has been defined, we will code the `display` function, to actually see something.


##Display

Display uses the **ggplot** library, a wierd and fucked-up piece of software, with so fancy graphic renderings it seems impossible not to use it.
For the record, we give the non-ggplot version first, using the `image` function. 

N.B. matrix plot is counter-clockwise rotated by an angle of pi/2 ; here we don't care as there is no orientation problems in this theoretic example. 
This is because, by convention, we "naturally" draw *rows* of a matrix along what would be the Y-axis of a plot. 
According to the documentation : 
> `image` interpret matrix as a table of f(x[i], y[j]) values, so that the x axis corresponds to row number and the y axis to >column number, with column 1 at the bottom, i.e. a 90 degree counter-clockwise rotation of the conventional printed layout of a matrix.

(the same phenomenon occurs with ggplot2 )


```{r displaySimple,fig.height=6, fig.width=6}
par(fin=c(6,6)) #plot size setup
image(state, axes = FALSE,col=c("red","blue"))
```


To obtain the ggplot version , the state data structure has to be tweaked a little bit.
ggplot2 needs a datastructure where each line is for an individual i.e. a piece of data, formed as follows:
```
    | Var1 | Var2 |    Var3  |
row1| 20   | 12.4 | "Batman" |
row2|  8   | 3.5  | "Robin"  |
```

in our case, pieces of data are householders, located in the grid (`Xcoord,Ycoord`), blelonging to a group (`value`) so we need something like: 

```
      | Xcoord | Ycoord | Group |
          ⋮       ⋮       ⋮ 
row_n |   24   |   75   |   2   |
          ⋮       ⋮       ⋮
row_p |   58   |    8   |   1   |
```


Starting from a matrix structure, this transformation is done by the `melt` function.


```{r meltGGplot}
library(ggplot2)
library(reshape2)
meltedState <- melt(state) 
head(meltedState,10)  #to see what it looks like and get the column names
```



```{r displayGGplot, fig.height=6, fig.width=6}
# color definitions  
colorMapping <- c("1"="red", "2"="blue") 

myggplot <- ggplot(meltedState, aes(x=Var1, y=Var2)) +
  geom_raster(aes(fill=factor(value)))+
 scale_fill_manual(values = colorMapping, na.value="lightgrey")+
  theme_void()
myggplot            

```

this does the job, 
yet we can improve rendering by drawing household in cells as points, in a scattermap-like way:


```{r displayGGplotfancy, fig.height=6, fig.width=6}
# color definitions  
library(RColorBrewer)
#fancyColors <- brewer.pal(3,"Accent")
# declaration of colors by name
fancyColors <- c("1"="bisque", "2"="aquamarine") 

myggplot2 <- ggplot(meltedState, aes(x=Var1, y=Var2)) +
  geom_point(size=1, aes(colour=factor(value)))+ #size has to be adjusted regarding the size of the state
 scale_color_manual( values=fancyColors, name="Group" )+
  theme_void()+
  coord_fixed(ratio = 1) + 
  ggtitle("Schelling state")
   
myggplot2            


```



## Dynamics

Each household "aims"" at finding a location where the proportion of similar households in the neighborhood (surrounding cells) is above a certain `tolerance` threshold.
   
 At each simulation step, each agent :
 
 1. looks around and establish the proportion of similar householder in its (Moore) nieghborhood
 2. if this proportion is below the threshold → looks for another place where the proportion is above , remains in place otherwise.
 
 
 To achieve this beahavior , we need a way to figure out :
 - the neighborhood af an house holder
 - where are the empty cells of the grid
 - where are the adequate cells for each group are (i.e. whose neighborhood proportion of same group is below the tolerance threshold)


### Getting the neighborhood

We will start with the Moore neighborhood (the 8 adjacents cells of a cell) ; this defintion could be extended in a later version.


Given a coordinate (i,j) in the state matrix, the neighborhood is given by the following code. 
Special cases of corner and border cells are treated by considering the environment as a torus.

```{r neighbors}

i <- 4
j <- 4

if (i==1){
if(j==1){
  neighborsAndMe <- state[c(size,i,i+1),c(size,j,j+1)] 
}
if(j==size){
  neighborsAndMe <- state[c(size,i,i+1),c(j-1,j,1)] 
}
  neighborsAndMe <- state[c(size,i,i+1),c(j-1,j,j+1)] 
}

if (i==size){
if(j==1){
 neighborsAndMe<- state[c(i-1,i,1),c(size,j, j+1)]
  }
if(j==size){
  neighborsAndMe <-state[c(i-1,i,1),c(j-1,j,1)]
}
  neighborsAndMe <-state[c(i-1,i,1),c(j-1,j,j+1)]
}



#regular cell case
neighborsAndMe <- state[c(i-1,i,i+1),c(j-1,j,j+1)] 
# flatten the 3x3 matrix
nieghborhood <- as.vector(neighborsAndMe)
#remove middle term (the caller cell i,j )
neighborhood <- neighborhood[-5]


getNeighbors <- function (i,j) {

  (0 %% 100)
  }
```








 